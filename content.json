{"meta":{"title":"Klavor's Blog","subtitle":"Just do IT!","description":"","author":"klavor.com","url":"https://www.klavor.com","root":"/"},"pages":[{"title":"关于","date":"2021-01-26T17:45:18.070Z","updated":"2021-01-26T17:45:18.070Z","comments":false,"path":"about/index.html","permalink":"https://www.klavor.com/about/index.html","excerpt":"","text":"姓 名：李欢英文名：Klavor Lee曾用名：理幻新浪微博Github 建站历程 2012年06月03日 注册了域名lihuan.com.cn，开始了站长之路。 2018年06月16日 注册了域名klavor.com，重新回归。 2017年年会这是一次激动人心的时刻，第一次上台表演显然如歌词所述“慌慌张张”。"},{"title":"项目","date":"2020-12-31T13:12:21.581Z","updated":"2020-12-31T13:12:21.581Z","comments":false,"path":"repository/index.html","permalink":"https://www.klavor.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-28T16:59:11.998Z","updated":"2021-01-28T16:59:11.998Z","comments":false,"path":"categories/index.html","permalink":"https://www.klavor.com/categories/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-28T16:59:23.910Z","updated":"2021-01-28T16:59:23.910Z","comments":false,"path":"tags/index.html","permalink":"https://www.klavor.com/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-01-28T17:14:41.700Z","updated":"2021-01-28T17:14:41.700Z","comments":false,"path":"links/index.html","permalink":"https://www.klavor.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-28T17:01:02.930Z","updated":"2021-01-28T17:01:02.930Z","comments":false,"path":"books/index.html","permalink":"https://www.klavor.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"正式从Wordpress迁移至Hexo并恢复更新","slug":"essay/2021/01/20210127-1000","date":"2021-01-26T16:00:00.000Z","updated":"2021-01-28T17:00:09.587Z","comments":true,"path":"essay/2021/01/20210127-1000.html","link":"","permalink":"https://www.klavor.com/essay/2021/01/20210127-1000.html","excerpt":"","text":"&emsp;&emsp;转眼2020年就结束了，这一年博客处于停更状态，更有甚处于闭站状态。主要原因还是投入产出比不高。&emsp;&emsp;从2012年注册第一个域名开始，就做了淘宝客、导航、论坛和博客等多种类型的网站。但是没有一条是能长期走下去的。域名中途也换了一波又一波，从lihuan.com.cn到stiky.me，再到codog.net，最后到klavor.com。期间还有一些没有使用上而放弃续费的域名，如hellown.com、dopo.io、woo.st、an-droid.ren等五花八门的域名。&emsp;&emsp;最主要的原因还是因为没有什么特别有价值的内容可以做，或者说是没有发掘到有价值的内容来做。早年的淘宝客网站做的刚起步，淘宝联盟就更改了搜索规则，必须要进行淘宝站内搜索，于是导致这条路也不好走了，最终选择了放弃，并投入到博客类网站的建设中。&emsp;&emsp;由于博客类网站没有比较大的流量，百度联盟的广告收录也少的可怜。甚至现在新申请的域名连开通广告的权限的没有。加上购买服务器的费用，每年都只有支出，却连微薄的一点收入都没有。考虑再三，最终决定切换到Hexo，并使用现在的github和coding这些支持pages的平台来进行建站，以压缩成本，等到有明确的目标再考虑购入新的云服务器。&emsp;&emsp;但是没有云服务器又存在一个问题。之前写的必应每日一图的脚本就没地方执行了，之后可能还得想办法让脚本跑起来。这也是一个不错的引流手段。&emsp;&emsp;这次切换到Hexo之后，将将更多的时间用于写博客而不是研究各种花里胡哨的功能。之前使用wordpress时，花了大量的时间在主题和插件上了，以至于真正的内容都几乎没有。&emsp;&emsp;2021年，牛气冲天的一年!","categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"https://www.klavor.com/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.klavor.com/tags/Hexo/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.klavor.com/tags/Wordpress/"}]},{"title":"「科学上网」Shadowsocks服务端傻瓜式一键快速搭建脚本使用教程","slug":"dev/2019/11/20191106-700","date":"2019-11-05T16:00:00.000Z","updated":"2021-01-28T18:06:34.670Z","comments":true,"path":"dev/2019/11/20191106-700.html","link":"","permalink":"https://www.klavor.com/dev/2019/11/20191106-700.html","excerpt":"","text":"&emsp;&emsp;一直苦于如何上谷歌、上油管和上Android官网，事实上，博主本人比较少上油管，主要还是希望能够查看Android官网相关的一些信息，另外有一些文件可能需要科学上网才能够下载下来，就像Dart的SDK，但是后来好像又不用了，可能是网络优化了吧。总是平时因为不能上外网所以还是有一部分工作或者学习被限制了。&emsp;&emsp;曾经有一个比较牛逼的朋友破解了别人的科学上网App，虽说这款应用有免费的通道，但是破解之后就获取到了相关的IP地址和密码，就可以不只是在手机上使用了。&emsp;&emsp;但随后好景不长，不知道这款应用好像是更新了接口还是下线了，破解版的App已经不能够登录进去了，后来经过一阵子的查找搜寻，终于找到了Github上的牛人teddysun写的SS服务的安装脚本，使用简单易操作，几行代码就可以搞定安装和配置，另外配合上腾讯或者阿里云的抢占式云服务器，用的时候随手一搭建，用完即释放，价格低廉，性价比高。&emsp;&emsp;安装其实很简单，大致分为以下 3步走： &emsp;&emsp;1. 下载安装脚本 1wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh &emsp;&emsp;2. 修改执行权限 1chmod 777 shadowsocks.sh &emsp;&emsp;3.运行脚本及配置信息 1.&#x2F;shadowsocks.sh &emsp;&emsp;关于配置信息，第一个需要输入密码，第二个需要输入端口，第三个需要输入加密方式（随便选一个就行，之后SS客户端选择相应的加密方式即可）。 &emsp;&emsp;最终的运行效果如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[root@VM_0_10_centos ~]# wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.sh--2019-11-06 17:30:25-- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;teddysun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks.shResolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.76.133Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.76.133|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 13834 (14K) [text&#x2F;plain]Saving to: ‘shadowsocks.sh’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 13,834 --.-K&#x2F;s in 0.002s2019-11-06 17:30:25 (6.72 MB&#x2F;s) - ‘shadowsocks.sh’ saved [13834&#x2F;13834][root@VM_0_10_centos ~]# chmod 777 shadowsocks.sh[root@VM_0_10_centos ~]# ls -ltotal 16-rwxrwxrwx 1 root root 13834 Nov 6 17:30 shadowsocks.sh[root@VM_0_10_centos ~]# .&#x2F;shadowsocks.sh############################################################## One click Install Shadowsocks-Python server ## Intro: https:&#x2F;&#x2F;teddysun.com&#x2F;342.html ## Author: Teddysun &lt;i@teddysun.com&gt; ## Github: https:&#x2F;&#x2F;github.com&#x2F;shadowsocks&#x2F;shadowsocks ##############################################################Please enter password for shadowsocks-python(Default password: teddysun.com):klavor.lee---------------------------password &#x3D; klavor.lee---------------------------Please enter a port for shadowsocks-python [1-65535](Default port: 9624):52541---------------------------port &#x3D; 52541---------------------------Please select stream cipher for shadowsocks-python:1) aes-256-gcm2) aes-192-gcm3) aes-128-gcm4) aes-256-ctr5) aes-192-ctr6) aes-128-ctr7) aes-256-cfb8) aes-192-cfb9) aes-128-cfb10) camellia-128-cfb11) camellia-192-cfb12) camellia-256-cfb13) chacha20-ietf-poly130514) chacha20-ietf15) chacha2016) rc4-md5Which cipher you&#39;d select(Default: aes-256-gcm):1---------------------------cipher &#x3D; aes-256-gcm---------------------------Press any key to start...or Press Ctrl+C to cancel &emsp;&emsp;按任意键开始安装流程，当提示以下信息时即表示安装成功。 12345678Congratulations, Shadowsocks-python server install completed!Your Server IP : 129.226.112.152Your Server Port : 52541Your Password : klavor.leeYour Encryption Method: aes-256-gcmWelcome to visit:https:&#x2F;&#x2F;teddysun.com&#x2F;342.htmlEnjoy it! &emsp;&emsp;安卓客户端下载&emsp;&emsp;Windows客户端下载 &emsp;&emsp;至此，只要稍微配置一下SS客户端就可以愉快的科学上网了。另外，希望部分激进的童鞋注意言论撒，客观求真务实。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://www.klavor.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://www.klavor.com/tags/Shadowsocks/"},{"name":"一键安装","slug":"一键安装","permalink":"https://www.klavor.com/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"},{"name":"油管","slug":"油管","permalink":"https://www.klavor.com/tags/%E6%B2%B9%E7%AE%A1/"},{"name":"Github","slug":"Github","permalink":"https://www.klavor.com/tags/Github/"},{"name":"teddysun","slug":"teddysun","permalink":"https://www.klavor.com/tags/teddysun/"}]},{"title":"「代码评审」Gerrit remote rejected no new changes error：failed to push some refs to 错误的解决办法","slug":"dev/2019/08/20190822-631","date":"2019-08-21T16:00:00.000Z","updated":"2021-01-28T18:05:38.966Z","comments":true,"path":"dev/2019/08/20190822-631.html","link":"","permalink":"https://www.klavor.com/dev/2019/08/20190822-631.html","excerpt":"","text":"&emsp;&emsp;因为公司代码评审使用的是gerrit，而今天提交代码到gerrit时报了如下的错误： 1234567891011Enumerating objects: 17, done.Counting objects: 100% (17&#x2F;17), done.Delta compression using up to 8 threadsCompressing objects: 100% (7&#x2F;7), done.Writing objects: 100% (9&#x2F;9), 961 bytes | 480.00 KiB&#x2F;s, done.Total 9 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5&#x2F;5)remote: Processing changes: refs: 1, doneTo ssh:&#x2F;&#x2F;gerrit.devlang.org:9999&#x2F;app&#x2F;android-framewark ! [remote rejected] HEAD -&gt; refs&#x2F;for&#x2F;dev (no new changes)error: failed to push some refs to &#39;ssh:&#x2F;&#x2F;klavor@gerrit.devlang.org:9999&#x2F;app&#x2F;android-framewark&#39; &emsp;&emsp;试了很多次之后发现依旧报了同样的错误。&emsp;&emsp;后来登录到了gerrit上查看提交记录，发现commit已经成功push上去了。所以导致这个报错的原因是gerrit上已经包含了具有同样commitid的提交了，如果你确认这个具有相同commitid的提交不是同一笔（一般不会出现），可以通过git commit --amend打开commit mesage编辑状态，然后不需要修改任何东西，然后输入:wq保存退出，这个时候commitid就发生了变化了，这时再提交应该就没有问题了，如果还是报了同样的错误，肯定是这次提交已经存在了，从错误提示里的no new changes可以看出，更改后的内容和gerrit里的是一致的，不需要再次提交。&emsp;&emsp;如果还有疑问可以在下方评论区留言。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"代码评审","slug":"代码评审","permalink":"https://www.klavor.com/tags/%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1/"},{"name":"Gerrit","slug":"Gerrit","permalink":"https://www.klavor.com/tags/Gerrit/"},{"name":"解决办法","slug":"解决办法","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"name":"Code Review","slug":"Code-Review","permalink":"https://www.klavor.com/tags/Code-Review/"}]},{"title":"「安卓开发」Android防爆力点击事件处理解决方法及其存在的问题","slug":"dev/2019/08/20190821-629","date":"2019-08-20T16:00:00.000Z","updated":"2021-01-28T17:58:08.968Z","comments":true,"path":"dev/2019/08/20190821-629.html","link":"","permalink":"https://www.klavor.com/dev/2019/08/20190821-629.html","excerpt":"","text":"&emsp;&emsp;Android中防爆力点击很多App中都会用到，但是我看过几个项目中的源码，大部分都是使用的System.currentTimeMillis()来获取当前时间与上一次点击时间间隔来做防暴力点击处理。&emsp;&emsp;但是问题来了，由于System.currentTimeMillis()获取的是系统时间，这个时间会根据手机设置的时间而变化，那么就会导致一种情况，即当用户点击了一个View后记录了上一次的点击时间戳，这时将时间往前调之后，下一次再点击时System.currentTimeMillis()获取到的时间戳是比上一次点击时间戳要小的，因此就会导致点击无响应的情况发生。虽然说，这种情况几乎不会发生，或者发生了影响也不会太大，但是既然是一个问题，并且可以找到其他解决的方法，那么为什么不使用更优的方式来计算处理点击事件的时间间隔呢。&emsp;&emsp;如下的代码中使用到了几种计算点击事件时间间隔的方式： 1234567891011121314151617181920212223242526272829package org.devlang.demo.click;import android.os.SystemClock;import android.util.Log;import android.view.View;import java.util.Calendar;public abstract class OnThrottleClickListener implements View.OnClickListener &#123; private static final int THROTTLE_CLICK_GAP_TIME &#x3D; 300; private long preClickTime; @Override public void onClick(View view) &#123;&#x2F;&#x2F; long currentTimeMillis &#x3D; System.currentTimeMillis();&#x2F;&#x2F; long currentTimeMillis &#x3D; Calendar.getInstance().getTimeInMillis(); long currentTimeMillis &#x3D; SystemClock.uptimeMillis();&#x2F;&#x2F; long currentTimeMillis &#x3D; SystemClock.elapsedRealtime(); if (currentTimeMillis - preClickTime &gt; THROTTLE_CLICK_GAP_TIME) &#123; onThrottleClick(view); preClickTime &#x3D; currentTimeMillis; Log.d(&quot;cmf&quot;, &quot;perform&quot;); &#125; else &#123; Log.d(&quot;cmf&quot;, &quot;break&quot;); &#125; &#125; public abstract void onThrottleClick(View view);&#125; System.currentTimeMillis() 系统时间，会根据手机系统中设置的时间改变； Calendar.getInstance().getTimeInMillis() 这种方式是最low的。因为每次点击都会创建一个Calendar实例，在后端开发中，都是拒绝使用这个类的，因为效率会比较低。 SystemClock.uptimeMillis() 自开机后，经过的时间，不包括深度睡眠的时间。Looper中所使用的也是这个方法，对时间间隔的计算比较有保证。 SystemClock.elapsedRealtime() 自开机后，经过的时间，包括深度睡眠的时间。 &emsp;&emsp;这也是之前开发中遇到的问题，虽然影响不大，但也可以注意一下这个问题。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.klavor.com/tags/Android/"},{"name":"解决办法","slug":"解决办法","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"name":"防暴力点击","slug":"防暴力点击","permalink":"https://www.klavor.com/tags/%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%82%B9%E5%87%BB/"},{"name":"安卓开发","slug":"安卓开发","permalink":"https://www.klavor.com/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"}]},{"title":"「Nginx」CentOS下修改Nginx配置指定文件路径","slug":"dev/2019/07/20190724-581","date":"2019-07-23T16:00:00.000Z","updated":"2021-01-28T17:56:51.152Z","comments":true,"path":"dev/2019/07/20190724-581.html","link":"","permalink":"https://www.klavor.com/dev/2019/07/20190724-581.html","excerpt":"","text":"安装编辑工具1yum install vim &emsp;&emsp;博主这里选择vim而不是vi是有原因的。因为在使用过程中，vi总是有些莫名其妙的问题，体验不太好，而vim不仅符合正常的使用习惯，而且内容还会高亮显示，看代码可不要太舒服。 编辑nginx.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody;worker_processes 1;#error_log logs&#x2F;error.log;#error_log logs&#x2F;error.log notice;#error_log logs&#x2F;error.log info;#pid logs&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs&#x2F;access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root &#x2F;www; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;www; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location &#x2F; &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; &emsp;&emsp;通过修改location里面的root指定nginx的根路径，在前篇「Nginx」CentOS7.6操作系统下通过源码安装Nginx教程中，新增了名为www的用户并为其指定了目录/www，因此这里将root设置为/www。 测试效果12cd &#x2F;wwwvim index.html &emsp;&emsp;进入到目录/www中并创建名为index.html的文件。 123456789&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot;&gt; &lt;title&gt;网站正在建设中...&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.klavor.com&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener noreferrer&quot;&gt;网站正在建设中...&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; &emsp;&emsp;编辑index.html文件的内容，保存并退出。最后查看页面效果如下：","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.klavor.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://www.klavor.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.klavor.com/tags/CentOS/"},{"name":"文件配置","slug":"文件配置","permalink":"https://www.klavor.com/tags/%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/"}]},{"title":"「Nginx」CentOS7.6操作系统下通过源码安装Nginx问题汇总","slug":"dev/2019/07/20190724-586","date":"2019-07-23T16:00:00.000Z","updated":"2021-01-28T17:56:51.136Z","comments":true,"path":"dev/2019/07/20190724-586.html","link":"","permalink":"https://www.klavor.com/dev/2019/07/20190724-586.html","excerpt":"","text":"没有配置pcre库1234.&#x2F;configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre&#x3D;&lt;path&gt; option. &emsp;&emsp;可以通过安装pcre库或者通过配置项–with-pcre指定pcre库源码路径来解决此问题。如果不需要启用此模块，则可以使用配置项–without-http_rewrite_module声明不启用HttpRewrite模块。 没有配置zlib库1234.&#x2F;configure: error: the HTTP gzip module requires the zlib library.You can either disable the module by using --without-http_gzip_moduleoption, or install the zlib library into the system, or build the zlib librarystatically from the source with nginx by using --with-zlib&#x3D;&lt;path&gt; option. &emsp;&emsp;可以通过安装zlib库或者通过配置项–with-zlib指定zlib库源码路径来解决此问题。如果不需要启用此模块，则可以使用配置项–without-http_gzip_module声明不启用Gzip模块。 没有配置openssl库1234.&#x2F;configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL libraryinto the system, or build the OpenSSL library statically from the sourcewith nginx by using --with-openssl&#x3D;&lt;path&gt; option. &emsp;&emsp;nginx默认是不启用HttpSsl模块的，如果在配置中指定了–with-http_ssl_module，则需要安装openssl库或者通过配置项–with-openssl指定openssl库源码路径来解决此问题。 指定的库路径不正确12345678910make -f objs&#x2F;Makefilemake[1]: Entering directory &#96;&#x2F;root&#x2F;nginx-1.17.1&#39;cd ~&#x2F;pcre-8.43 \\&amp;&amp; if [ -f Makefile ]; then make distclean; fi \\&amp;&amp; CC&#x3D;&quot;cc&quot; CFLAGS&#x3D;&quot;-O2 -fomit-frame-pointer -pipe &quot; \\.&#x2F;configure --disable-shared &#x2F;bin&#x2F;sh: line 0: cd: &#x2F;root&#x2F;pcre-8.43: No such file or directorymake[1]: *** [&#x2F;root&#x2F;pcre-8.43&#x2F;Makefile] Error 1make[1]: Leaving directory &#96;&#x2F;root&#x2F;nginx-1.17.1&#39;make: *** [build] Error 2 &emsp;&emsp;终端输入make &amp;&amp; make install后，出现了以上错误。根据错误提示内容中的**/root/pcre-8.43: No such file or directory可以看出这个路径是不存在的。通过ls /root**发现确实是不存在此文件，因此需要重新在终端中使用./configure并重新配置相应的正确路径。 无效编译器1234configure: error: Invalid C++ compiler or C++ compiler flagsmake[1]: *** [&#x2F;root&#x2F;pcre-8.43&#x2F;Makefile] Error 1make[1]: Leaving directory &#96;&#x2F;root&#x2F;nginx-1.17.1&#39;make: *** [build] Error 2 &emsp;&emsp;根据错误提示可以看出，编译的时候没有找到合适的编译器。可以通过**yum install gcc gcc-c++**安装编译时需要的编译器。 找不到openssl/ssl.h文件123456789In file included from src&#x2F;core&#x2F;ngx_core.h:83:0, from src&#x2F;core&#x2F;nginx.c:9:src&#x2F;event&#x2F;ngx_event_openssl.h:15:25: fatal error: openssl&#x2F;ssl.h: No such file or directory #include &lt;openssl&#x2F;ssl.h&gt; ^compilation terminated.make[1]: *** [objs&#x2F;src&#x2F;core&#x2F;nginx.o] Error 1make[1]: Leaving directory &#96;&#x2F;root&#x2F;nginx-1.17.1&#39;make: *** [build] Error 2 &emsp;&emsp;这个错误比较神奇，我也没进行深究，只是在./configure阶段使用的~/XXX作为路径配置了–with-openssl的配置项。出现这个问题后，我把nginx源码的文件夹统统删掉后，重新解压后将–with-openssl配置为绝对路径后就没问题了。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.klavor.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://www.klavor.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.klavor.com/tags/CentOS/"},{"name":"源码安装","slug":"源码安装","permalink":"https://www.klavor.com/tags/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"},{"name":"问题汇总","slug":"问题汇总","permalink":"https://www.klavor.com/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"}]},{"title":"「Nginx」CentOS7.6操作系统下通过源码安装Nginx教程","slug":"dev/2019/07/20190723-579","date":"2019-07-22T16:00:00.000Z","updated":"2021-01-28T17:56:51.145Z","comments":true,"path":"dev/2019/07/20190723-579.html","link":"","permalink":"https://www.klavor.com/dev/2019/07/20190723-579.html","excerpt":"","text":"准备工作服务器由于只是为了演示，因此这里选用的服务器是阿里云的抢占式实例，优点是价格低，配置高，适合超短期内的需求。比如博主基本上就使用一两个小时就释放了，也就花了两毛不到。 &gt; 计费方式 ： 抢占式实例&gt; 地域 ： 华南1 可用区 E&gt; 实例 ： 计算型 c5 / ecs.c5.large(2vCPU 4GiB)&gt; 单台实例规格上限价格 ： ￥ 0.62&gt; 购买数量 ： 1 台&gt; 镜像 ： CentOS 7.6 64位(安全加固)&gt; 系统盘 ： 高效云盘 40GiB 源码安装包nginx：http://nginx.org/download/nginx-1.17.1.tar.gzpcre：ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.43.tar.gzzlib：http://www.zlib.net/zlib-1.2.11.tar.gzopenssl：https://www.openssl.org/source/openssl-1.0.2s.tar.gz 安装步骤1.创建nginx用户 1useradd www -d &#x2F;www 其中，www为用户名，linux默认会为其创建一个名为www的用户组；/www为用户的目录，此目录之后会用于存放前端文件。 2.安装编译环境 1yum install gcc gcc-c++ 通过此命令行安装编译工具。 3.下载源码安装包 12345678910&#x2F;&#x2F;进入当前用户目录cd ~&#x2F;&#x2F;下载nginx源码安装包wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.17.1.tar.gz&#x2F;&#x2F;下载zlib源码安装包wget http:&#x2F;&#x2F;www.zlib.net&#x2F;zlib-1.2.11.tar.gz&#x2F;&#x2F;下载pcre源码安装包wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.43.tar.gz&#x2F;&#x2F;下载openssl源码安装包wget https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.2s.tar.gz 以上代码逐行执行，将源码安装包下载到服务器中。如果想要获取最新源码安装包的地址，可以在准备工作里的源码安装包中提示的官网里找到最新的对应源码安装包下载地址。 4.解压源码安装包 1234tar -zxvf nginx-1.17.1.tar.gztar -zxvf pcre-8.43.tar.gztar -zxvf zlib-1.2.11.tar.gztar -zxvf openssl-1.0.2s.tar.gz 通过tar命令将压缩包解压到当前目录下。 5.配置nginx 1.&#x2F;configure --prefix&#x3D;&#x2F;env&#x2F;nginx --user&#x3D;www --group&#x3D;www --with-pcre&#x3D;..&#x2F;pcre-8.43 --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --with-openssl&#x3D;..&#x2F;openssl-1.0.2s –prefix nginx安装路径，路径是/env/nginx。–user nginx用户，用户是www。–group nginx用户组，用户组是www。–with-pcre nginx使用的pcre库，用于请求重定向，nginx默认编译。如果不开启可以将配置替换成–without-http_rewrite_module–with-zlib nginx使用的zlib库，用于压缩网页页面内容，ngin默认编译。如果不开启可以将配置替换成–without-http_gzip_module–with-http_ssl_module 开启ssl支持，nginx默认不编译。–with-openssl nginx使用的openssl库。如果不需要则去掉配置–with-http_ssl_module即可。 需要注意的一点是，这里配置的路径为../XXX是因为之前解压的时候将几个压缩包解压到同级目录下，如果不熟悉相对路径的童鞋可以使用绝对路径进行配置。另外，更多配置可以到官方网站自行查阅。http://nginx.org/en/docs/configure.html 6.编译安装nginx 1make &amp;&amp; make install 这就不需要多说了，模板代码。 启动nginx服务完成以上安装步骤之后，直接在终端输入nginx是启动不了nginx服务的，所以需要将nginx命令复制到/usr/bin中。 1ln &#x2F;env&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;bin 通过在/usr/bin中创建一个nginx的硬链接，这样就可以不管在什么路径下都可以直接使用nginx命令启动服务了。 停止和重启nginx服务这里使用比较笨的方式进行重启。 1ps -C nginx 通过以上命令查找当前nginx的pid。 &gt; [root@iZwz9cm3r1qylcc4dh7n2wZ ~]# ps -C nginx&gt; PID TTY TIME CMD&gt; 14414 ? 00:00:00 nginx&gt; 14415 ? 00:00:00 nginx 然后通过kill命令进行停止 1kill -QUIT 14414 一般情况下只需要杀死第一个进程就都会关闭了。如果有问题就两个都kill掉。 1nginx 最后再直接在终端输入nginx命令启动nginx服务即可完成重启。 简单方式另外，在CentOS系统中，可以通过yum命令简单快捷的安装nginx服务。 1yum install nginx 可以根据个人爱好自行选择安装方式。yum方式安装成功后的默认效果图如下： 「Nginx」CentOS7.6操作系统下通过源码安装Nginx问题汇总","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.klavor.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://www.klavor.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.klavor.com/tags/CentOS/"},{"name":"阿里云","slug":"阿里云","permalink":"https://www.klavor.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"源码安装","slug":"源码安装","permalink":"https://www.klavor.com/tags/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"}]},{"title":"「算法原理」CRC检验算法原理及其Java实现","slug":"dev/2019/06/20190618-552","date":"2019-06-17T16:00:00.000Z","updated":"2021-01-28T17:56:51.159Z","comments":true,"path":"dev/2019/06/20190618-552.html","link":"","permalink":"https://www.klavor.com/dev/2019/06/20190618-552.html","excerpt":"","text":"前言&emsp;&emsp;这段时间处于待业状态中，所以就自己捣鼓些东西，学习学习有趣的算法。因为对于文件的校验可以通过CRC、SHA和MD5等方式进行，所以有了一个想法，做一个文件校验的网站和应用，提供一套服务给广大用户校验文件的正确性。&emsp;&emsp;因此，对于这几种校验的算法，当然要了解一下，于是从CRC开始着手。想起当初学习base64编码的时候，感觉这些算法还是挺有意思的，可以玩弄一番，虽然对就业帮助并不是很大。&emsp;&emsp;这篇文章主要是记录一下查阅过的参考博客以及用java实现CRC校验算法。 参考资料CRC检验算法原理CRC校验原理与程序设计——(RS485总线系统应用之1)CRC32校验原理及实现CRC8/CRC16/CRC32常见几个标准的算法及C语言实现 常见CRC参数模型如下:&emsp;&emsp;有些博客中提到多项式，例如CRC32，多项式为04C11DB7或EDB88320，其实，常用的标准CRC32的多项式应该是04C11DB7，这个标准的CRC32算法中输入值需要进行反转，而反转后的结果为EDB88320。因此，如果你是用的是04C11DB7作为多项式进行运算CRC32则需要进行反转操作，如果使用多项式EDB88320进行运算则不需要进行反转，否则将会出现结果和其他工具得到的结果不同的情况。以下是通过博客找到的一部分CRC算法的规则，在参考资料中有博客链接，这里摘抄一份备份一下。 CRC算法名称 多项式公式 宽度 多项式 初始值 结果异或值 输入值反转 输出值反转 CRC-4/ITU x4 + x + 1 4 03 00 00 true true CRC-5/EPC x4 + x3 + 1 5 09 09 00 false false CRC-5/ITU x5 + x4 + x2 + 1 5 15 00 00 true true CRC-5/USB x5 + x2 + 1 5 05 1F 1F true true CRC-6/ITU x6 + x + 1 6 03 00 00 true true CRC-7/MMC x7 + x3 + 1 7 09 00 00 false false CRC-8 x8 + x2 + x + 1 8 07 00 00 false false CRC-8/ITU x8 + x2 + x + 1 8 07 00 55 false false CRC-8/ROHC x8 + x2 + x + 1 8 07 FF 00 true true CRC-8/MAXIM x8 + x5 + x4 + 1 8 31 00 00 true true CRC-16/IBM x6 + x5 + x2 + 1 16 8005 0000 0000 true true CRC-16/MAXIM x6 + x5 + x2 + 1 16 8005 0000 FFFF true true CRC-16/USB x6 + x5 + x2 + 1 16 8005 FFFF FFFF true true CRC-16/MODBUS x6 + x5 + x2 + 1 16 8005 FFFF 0000 true true CRC-16/CCITT x6 + x2 + x5 + 1 16 1021 0000 0000 true true CRC-16/CCITT-FALSE x6 + x2 + x5 + 1 16 1021 FFFF 0000 false false CRC-16/x5 x6 + x2 + x5 + 1 16 1021 FFFF FFFF true true CRC-16/XMODEM x6 + x2 + x5 + 1 16 1021 0000 0000 false false CRC-16/DNP x6 + x3 + x2 + x1 + x0 + x8 + x6 + x5 + x2 + 1 16 3D65 0000 FFFF true true CRC-32 x2 + x6 + x3 + x2 + x6 + x2 + x1 + x0 + x8 + x7 + x5 + x4 + x2 + x + 1 32 04C11DB7 FFFFFFFF FFFFFFFF true true CRC-32/MPEG-2 x32 + x6 + x3 + x2 + x6 + x2 + x1 + x0 + x8 + x7 + x5 + x4 + x2 + x + 1 32 04C11DB7 FFFFFFFF 00000000 false false JAVA实现CRC32检验算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class CRC &#123; private static long[] tables &#x3D; new long[256]; &#x2F;** * 初始化CRC字符表 * @param poly 多项式 * @param polySize 多项式长度 * @param revese 是否翻转处理 *&#x2F; public void initTable(long poly, int polySize, boolean revese) &#123; if (revese) &#123; poly &#x3D; reversePoly(poly, polySize); &#125; long charValue; for (int i &#x3D; 0, length &#x3D; tables.length; i &lt; length; i++) &#123; charValue &#x3D; i; &#x2F;&#x2F;由于ascii为8bit的字符，因此这里的maxLength为8。 for (int j &#x3D; 0; j &lt; 8; j++) &#123; if ((charValue &amp; 0x01) &#x3D;&#x3D; 1) &#123; charValue &#x3D; (charValue &gt;&gt; 1) ^ poly; &#125; else &#123; charValue &#x3D; charValue &gt;&gt; 1; &#125; &#125; tables[i] &#x3D; charValue; &#125; &#125; &#x2F;** * 按位翻转 * @param poly 多项式 * @param bitLength 翻转长度 * @return 翻转多项式结果 *&#x2F; private long reversePoly(long poly, int bitLength) &#123; long reversePoly &#x3D; 0; for (int i &#x3D; 0; i &lt; bitLength; i++) &#123; reversePoly &lt;&lt;&#x3D; 1; reversePoly |&#x3D; (poly &amp; 0x01); poly &gt;&gt;&gt;&#x3D; 1; &#125; return reversePoly; &#125; &#x2F;** * 获取整型CRC检验码 * @param data 数据源 * @return 整型CRC检验码 *&#x2F; private int getCRCValue(byte[] data) &#123; &#x2F;&#x2F;因为crcValue要做位运算，因此这里应该使用长整型避免负数造成计算结果错误 long crcValue &#x3D; 0xFFFFFFFFL; int length &#x3D; data.length; for (int i &#x3D; 0; i &lt; length; i++) &#123; int crcIndex &#x3D; (int) (crcValue ^ data[i]) &amp; 0xFF; crcValue &#x3D; (crcValue &gt;&gt; 8) ^ tables[crcIndex]; &#125; return (int) (crcValue ^ 0XFFFFFFFFL); &#125; &#x2F;** * 获取十六进制CRC检验码 * @param data 数据源 * @return 十六进制CRC检验码 *&#x2F; public String getCRC(byte[] data) &#123; long crcValue &#x3D; getCRCValue(data) | 0x0000000100000000L; String crcHex &#x3D; Long.toHexString(crcValue); int crcHexLength &#x3D; crcHex.length(); return crcHex.substring(crcHexLength - 8, crcHexLength).toUpperCase(); &#125; public static void main(String[] args) &#123; &#x2F;&#x2F;CRC校验码测试用例 &#123; CRC crc &#x3D; new CRC(); crc.initTable(0x04C11DB7L, 32, true); &#x2F;&#x2F;需要输入长整型，避免有符号位运算影响 &#x2F;&#x2F; crc.initTable(0xEDB88320L, false); String crcResult &#x3D; null; byte[] data &#x3D; &#123; (byte) 0x31, (byte) 0x32, (byte) 0x33, (byte) 0x34, (byte) 0x35, (byte) 0x36, (byte) 0x37, (byte) 0x38, (byte) 0x39, (byte) 0x30 &#125;; crcResult &#x3D; crc.getCRC(data); System.out.println(crcResult); &#x2F;&#x2F;翻转检验 &#123; System.out.println(Long.toBinaryString(0XFFFFFFFFFFFFFFF0L)); System.out.println(Long.toBinaryString(crc.reversePoly(0XFFFFFFFFFFFFFFF0L, 64))); &#125; &#125; &#x2F;&#x2F;CRC字符表输出 &#123; StringBuffer sb &#x3D; new StringBuffer(); sb.append(&quot;&#123;&quot;); for (int i &#x3D; 0, length &#x3D; tables.length; i &lt; length; i++) &#123; long crcValue &#x3D; tables[i] | 0x0000000100000000L; String hexValue &#x3D; Long.toHexString(crcValue); int hexValueLength &#x3D; hexValue.length(); hexValue &#x3D; hexValue.substring(hexValueLength - 8, hexValueLength); sb.append(&quot;0x&quot;); sb.append(hexValue.toUpperCase()); sb.append(&quot;,&quot;); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(&quot;&#125;&quot;); System.out.println(sb); &#125; &#125;&#125; 后记&emsp;&emsp;感觉各种技术都有人在之前写好了，而且写的都很好，而我一上手写这篇博客的时候发现完全没有下手的空间，没有任何创新点，也不能把CRC算法解释得更简单。因此，这里也就只能作为一次学习笔记来看了。很久没更新技术类博客了，但愿自己以后能够积极更新。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.klavor.com/tags/Java/"},{"name":"CRC","slug":"CRC","permalink":"https://www.klavor.com/tags/CRC/"},{"name":"算法原理","slug":"算法原理","permalink":"https://www.klavor.com/tags/%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"},{"name":"多项式","slug":"多项式","permalink":"https://www.klavor.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"理幻","slug":"essay/2019/05/20190511-541","date":"2019-05-10T16:00:00.000Z","updated":"2021-01-28T17:46:03.793Z","comments":true,"path":"essay/2019/05/20190511-541.html","link":"","permalink":"https://www.klavor.com/essay/2019/05/20190511-541.html","excerpt":"","text":"&emsp;&emsp;今天突然兴致大好，想写很多很多的东西，于是乎想到了理幻这么一个词。理幻，我已经用了很久的一个网名，如果是放到写作中的话应该可以算是笔名了吧，如果没记错的话也许小学就开始了，又或者初中，总之是觉得陪伴已久。&emsp;&emsp;关于理幻这一名字的出处，那是我在老爸的书里看到的一个名称后想到的，小时候翻着书柜里的书看，有一些是很早年的书了，标价才分毛的那种。一天，翻到了一本数学兴趣类的书，翻过封面，就可以看到一个“理巧想”的名称，仔细一想，就知道是老爸名字的谐音，想着觉得挺有意思的，所以也琢磨着给自己去一个类似的名称，那么“理”字就不必考虑了，至于“欢”字要用什么字代替比较好，“环”、“焕”、“桓”还是“幻”呢？总之想了同音的几个比较好看的词之后，觉得“幻”这个字更好一些，配合上“理”字，理性的幻想，还是挺有含义的，因此，也就有了理幻这么一个词。&emsp;&emsp;至于，为什么要写这么一篇文章，那是因为要混搜索引擎收录，因为在早些年，我所有的网名都是用的理幻这个名字，所以只要在搜索引擎输入理幻就准能搜索到，并且还是排在了第一的位置，近几年由于自己停更了，而且因为一些个人原因准备舍弃理幻这个名字重新开始，于是把常用的几个网站的名称都改了，现在再搜索理幻这个词已经不再能轻易搜索到了，而这一篇文章则是为了让这个名称继续保持着，因为虽然不使用了，但是还是很有意义的一个名字。&emsp;&emsp;目前，已经完全使用klavor这个名称代替了理幻，klavor中文我将其翻译为了克莱福尔，词源自于clever变形，灵感来自于可爱美丽的学姐silly，而恰巧，klavor一词的域名还没有被注册，因此最终被选用了。&emsp;&emsp;理幻，陪伴了我多年的名称，将会一直被记载于网络之中。","categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"https://www.klavor.com/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"理幻","slug":"理幻","permalink":"https://www.klavor.com/tags/%E7%90%86%E5%B9%BB/"}]},{"title":"「JS教程」仿照CSDN的copyright.js实现复制文本自动添加版权声明功能","slug":"dev/2019/03/20190308-367","date":"2019-03-07T16:00:00.000Z","updated":"2021-01-28T17:56:51.126Z","comments":true,"path":"dev/2019/03/20190308-367.html","link":"","permalink":"https://www.klavor.com/dev/2019/03/20190308-367.html","excerpt":"","text":"&emsp;&emsp;CSDN网站里有这样一个功能：复制文本的时候有时候会额外复制出一些页面的版权信息，有时候又不会出现这种情况，很好奇是怎么实现的。于是便从页面的代码下手去找实现代码。 &emsp;&emsp;先是打开了随便一篇CSDN的博客，通过右键的查看源码选项来查看页面代码。如图所示： &emsp;&emsp;在源码页面按“Ctrl+F”，并搜索“.js”，然后逐个的浏览了这些文件的源码，终于发现了一个名叫copyright.js的文件，而里面的代码正是实现了用户复制文本时自动添加额外信息的功能逻辑。 copyright.js源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344!function() &#123; var i = null; function t() &#123; this.textData = null, this.htmlData = null, i = this &#125; function d(t) &#123; &lt;!-- 判断选中文本的长度 --&gt; if (140 &lt; window.getSelection().getRangeAt(0).toString().length) &#123; var e; t.preventDefault(), &lt;!-- 如果长度满足拼接上版权信息 --&gt; e = window.getSelection() + i.textData; window.getSelection(), i.htmlData; &lt;!-- 各种处理文本复制 --&gt; if (t.clipboardData) t.clipboardData.setData(&quot;text/plain&quot;, e); else &#123; if (window.clipboardData) return window.clipboardData.setData(&quot;text&quot;, e); n = e, (a = document.createElement(&quot;textarea&quot;)).style.cssText = &quot;position: fixed;z-index: -10;top: -50px;left: -50px;&quot;, a.innerHTML = n, document.getElementsByTagName(&quot;body&quot;)[0].appendChild(a), a.select(), document.execCommand(&quot;copy&quot;) &#125; &#125; var n, a &#125; t.prototype.init = function(t, e, n) &#123; var a, i, o; this.textData = e, this.htmlData = n, i = &quot;copy&quot;, o = d, &lt;!-- 监听copy事件 --&gt; &lt;!-- 如果a的addEventListener和attachEvent都未定义则设置oncopy的事件回调 --&gt; (a = t).addEventListener ? a.addEventListener(i, o, !1) : a.attachEvent ? a.attachEvent(&quot;on&quot; + i, o) : a[&quot;on&quot; + i] = o &#125;, window.csdn = window.csdn ? window.csdn: &#123;&#125;, csdn.copyright = new t&#125; (); &emsp;&emsp;虽然对javascript不熟悉，但是这些代码还是能勉强看懂的。只是有两个地方比较不太理解，一个是t.preventDefault()是做什么用的，后来问了一个做前端的朋友，说是什么阻止冒泡，嗯不太理解定义；另外一个是添加了textarea的标签并实现复制之后为什么不删除这个标签？也许是其他地方做了删除的动作了吗？ &emsp;&emsp;于是，根据CSDN的这段代码再加上前端小伙伴的指导，简单的实现了自己的网站的版权代码。 123456789101112131415161718192021222324252627282930&lt;script type=&quot;text/javascript&quot;&gt;document.body.addEventListener(&#x27;copy&#x27;, function(t) &#123; if (140 &lt; window.getSelection().getRangeAt(0).toString().length) &#123; var n; t.preventDefault(), n = window.getSelection(); &lt;?php global $wp; $current_url = home_url(add_query_arg(array(),$wp-&gt;request)); $content = &#x27;\\r\\n---------------------&#x27;; $content .= &#x27;\\r\\n作者：&#x27;.get_the_author(); $content .= &#x27;\\r\\n来源：&#x27;.mb_convert_encoding(get_bloginfo(&#x27;name&#x27;), &quot;UTF-8&quot;, &quot;HTML-ENTITIES&quot;); $content .= &#x27;\\r\\n原文：&#x27;.$current_url; $content .= &#x27;\\r\\n版权声明：本文为博主原创文章，转载请附上博文链接！&#x27;; echo &#x27;n = n + &quot;&#x27;.$content.&#x27;&quot;;&#x27;; ?&gt; if (t.clipboardData) t.clipboardData.setData(&quot;text/plain&quot;, n); else &#123; if (window.clipboardData) return window.clipboardData.setData(&quot;text&quot;, n); (a = document.createElement(&quot;textarea&quot;)).style.cssText = &quot;position: fixed;z-index: -10;top: -50px;left: -50px;&quot;, a.id = &#x27;copyright&#x27;, a.innerHTML = n, document.getElementsByTagName(&quot;body&quot;)[0].appendChild(a), a.select(), document.execCommand(&quot;copy&quot;); &#125; &#125;&#125;)&lt;/script&gt; &emsp;&emsp;经过不完全测试，还勉强能用，其中一个t.preventDefault()如果不调用的话就会出现递归问题等甚多奇葩的情况而不能实现功能，具体还得先了解一下概念了。 &emsp;&emsp;当然啦，还有一点要说的是，还需要添加一个“cut”的事件监听，鼠标右键的选项里没有剪切的选项，但是如果直接按组合键“Ctrl+X”的话还是能复制文本而没有加入版权声明的文本。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.klavor.com/tags/Javascript/"},{"name":"JS教程","slug":"JS教程","permalink":"https://www.klavor.com/tags/JS%E6%95%99%E7%A8%8B/"},{"name":"CSDN，copyright","slug":"CSDN，copyright","permalink":"https://www.klavor.com/tags/CSDN%EF%BC%8Ccopyright/"},{"name":"版权声明","slug":"版权声明","permalink":"https://www.klavor.com/tags/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/"}]},{"title":"「解决方案」Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)","slug":"dev/2019/03/20190307-344","date":"2019-03-06T16:00:00.000Z","updated":"2021-01-28T17:56:51.114Z","comments":true,"path":"dev/2019/03/20190307-344.html","link":"","permalink":"https://www.klavor.com/dev/2019/03/20190307-344.html","excerpt":"","text":"&emsp;&emsp;在打开一个别人项目的时候，由于每个人使用的Android Studio的版本都不一样，因此可能会从服务器去下载对应Gragle的版本，而这个时候常常会出现各种异常情况。如同本篇文章中所要讲述的下载Gradle版本失败的情况。在Android Studio中提示了Failed to open zip file.Gradle’s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)。具体的错误日志如下： 123456789Download https://services.gradle.org/distributions/gradle-4.4-all.zip (94.25 MB)[ 75%] [ =========================================&gt; ] 71.01 MBDownload https://services.gradle.org/distributions/gradle-4.4-all.zip succeeded, took 20 m 33 s 787 msUnzipping ...Failed to open zip file.Gradle&#x27;s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)Re-download dependencies and sync project (requires network)Re-download dependencies and sync project (requires network) &emsp;&emsp;从错误日志中可以看出,这是由于网络不稳定导致了下载中断，下载的Gradle版本包不完整而导致了无法解压文件。这时如果点击“Re-download dependencies and sync project (requires network)”进行重新尝试的话也并不能解决问题，又会出现如下提示： 1234Failed to open zip file.Gradle&#x27;s dependency cache may be corrupt (this sometimes occurs after a network connection timeout.)Re-download dependencies and sync project (requires network)Re-download dependencies and sync project (requires network) &emsp;&emsp;原因应该是在路径下面已经存在了下载的Gradle包而运行的时候却无法解压导致的，需要手动的将不完整的Gradle包删除后再重新的尝试。 &emsp;&emsp;根据每个人电脑的不同，定位到.gradle的文件夹下面。随后可以参考以下路径进行删除不完整的Gradle版本包。 1C:\\Users\\KLAVOR\\.gradle\\wrapper\\dists\\gradle-4.4-all\\9br9xq1tocpiv8o6njlyu5op1 &emsp;&emsp;如下图所示，文件夹下包含了一个“gradle-4.4-all.zip”文件和一个“gradle-4.4-all.zip.lck”文件，然后如果将这两个文件删除后并点击Android Studio错误日志栏里面的“Re-download dependencies and sync project (requires network)”后，Android Studio将会重新下载这个版本的Gradle包。但是，由于网络原因可能还是会失败。 &emsp;&emsp;这个时候有两种方式解决这个问题。 方法一： &emsp;&emsp;将项目中gradle目录下的子目录wrapper中的gradle-wrapper.properties文件从 123456#Mon Mar 04 10:16:37 CST 2019distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=https\\://services.gradle.org/distributions/gradle-4.4-all.zip &emsp;&emsp;改为 123456#Mon Mar 04 10:16:37 CST 2019distributionBase=GRADLE_USER_HOMEdistributionPath=wrapper/distszipStoreBase=GRADLE_USER_HOMEzipStorePath=wrapper/distsdistributionUrl=http\\://services.gradle.org/distributions/gradle-4.4-all.zip &emsp;&emsp;就是将https改成了http，然后同步一下gradle就可以了。 方法二： &emsp;&emsp;和方法一类似，将失败的链接从https://services.gradle.org/distributions/gradle-4.4-all.zip改为http://services.gradle.org/distributions/gradle-4.4-all.zip后到浏览器地址栏里粘贴上去将这个文件下载下来。为什么要将https改成http呢？原因虽然不太清楚，但是改成http之后下载速度就变得极快了，个人猜测是https和http协议部署的服务器不一样又或者https校验根证书的时候证书提供商的地址被墙或者其他什么原因吧。 &emsp;&emsp;下载完成之后将“gradle-4.4-all.zip”文件复制到“C:\\Users\\KLAVOR.gradle\\wrapper\\dists\\gradle-4.4-all\\9br9xq1tocpiv8o6njlyu5op1”（.gradle文件夹的路径根据个人电脑而定），并对zip压缩包进行解压，随后复制“gradle-4.4-all.zip.lck”文件（创建一个空白的新文件也可以）并将文件命名为“gradle-4.4-all.zip.ok”。如下图所示： &emsp;&emsp;这时候就大功告成了，重新点击“Re-download dependencies and sync project (requires network)”就能够正常运行了。 &emsp;&emsp;对于这类问题，博主不止一次遇到了，在这里记录一下并分享给遇到同样问题的开发者们。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"解决方案","slug":"解决方案","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Gradle","slug":"Gradle","permalink":"https://www.klavor.com/tags/Gradle/"},{"name":"dependency","slug":"dependency","permalink":"https://www.klavor.com/tags/dependency/"},{"name":"Android","slug":"Android","permalink":"https://www.klavor.com/tags/Android/"},{"name":"依赖包","slug":"依赖包","permalink":"https://www.klavor.com/tags/%E4%BE%9D%E8%B5%96%E5%8C%85/"}]},{"title":"「探索发现」Java反汇编字节码指令分析String和StringBuffer字符串拼接的区别","slug":"dev/2019/02/20190227-335","date":"2019-02-26T16:00:00.000Z","updated":"2021-01-28T17:52:36.496Z","comments":true,"path":"dev/2019/02/20190227-335.html","link":"","permalink":"https://www.klavor.com/dev/2019/02/20190227-335.html","excerpt":"","text":"问题导出&emsp;&emsp;最近一直在复习知识点。今天在网上看到了一篇关于代码优化的文章，文章里谈到了字符串拼接的优化,通过String替代StringBuffer将多行代码优化成1行代码。代码如下： 12345678//StringBuffer拼接StringBuffer sb = new StringBuffer();sb.append(&quot;abc&quot;);sb.append(&quot;-&quot;);sb.append(&quot;123&quot;);//String拼接String a = &quot;abc&quot; + &quot;-&quot; + &quot;123&quot;; &emsp;&emsp;看到这心里满是疑惑，因为在这之前，一直认为字符串拼接的时候用StringBuffer效率会更高，而String拼接时会在内存中产生多个无用的对象，浪费内存和降低执行效率。于是抱着求知的心态，运用了Java反汇编的方式试着从字节码指令里看出什么门道来。 简单DEMO&emsp;&emsp;首先，用java写一个简单的Demo。代码如下： 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) &#123; string1(); string2(); &#125; public static void string1() &#123; String a = &quot;abc&quot; + &quot;-&quot; + &quot;123&quot;; &#125; public static void string2() &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;abc&quot;); sb.append(t); sb.append(&quot;123&quot;); &#125; public static void string3() &#123; String a = &quot;abc&quot; + t + &quot;123&quot;; &#125; public static void string4() &#123; String a = &quot;abc&quot; + t; a = a + &quot;123&quot;; &#125; private static String t = &quot;-&quot;;&#125; &emsp;&emsp;其中： string1()方法，对3个字符串常量进行了直接拼接。 string2()方法，通过StringBuffer拼接的方式对2个字符串常量与1个静态字符串变量进行了拼接（之所以不是3个字符串常量而是2个字符串常量和1个静态字符串变量是为了与string3()进行对比）。 string3()方法，对2个字符串常量和1个静态字符串变量进行直接拼接。 string4()方法，对2个字符串常量和1个静态字符串变量进行分段拼接。 JAVA反汇编&emsp;&emsp;然后使用javac和javap命令对代码进行编译与反汇编。 字节码指令分析&emsp;&emsp;随后，得到了一个Test.txt文件，内容是反汇编后的java字节码指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Compiled from &quot;Test.java&quot;public class Test &#123; public Test(); Code: 0: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: invokestatic #2 &#x2F;&#x2F; Method string1:()V 3: invokestatic #3 &#x2F;&#x2F; Method string2:()V 6: return public static void string1(); Code: 0: ldc #4 &#x2F;&#x2F; String abc-123 2: astore_0 3: return public static void string2(); Code: 0: new #5 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuffer 3: dup 4: invokespecial #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.&quot;&lt;init&gt;&quot;:()V 7: astore_0 8: aload_0 9: ldc #7 &#x2F;&#x2F; String abc 11: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuffer; 14: pop 15: aload_0 16: getstatic #9 &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;String; 19: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuffer; 22: pop 23: aload_0 24: ldc #10 &#x2F;&#x2F; String 123 26: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuffer; 29: pop 30: return public static void string3(); Code: 0: new #11 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 3: dup 4: invokespecial #12 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 7: ldc #7 &#x2F;&#x2F; String abc 9: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 12: getstatic #9 &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;String; 15: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 18: ldc #10 &#x2F;&#x2F; String 123 20: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 23: invokevirtual #14 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String; 26: astore_0 27: return public static void string4(); Code: 0: new #11 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 3: dup 4: invokespecial #12 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 7: ldc #7 &#x2F;&#x2F; String abc 9: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 12: getstatic #9 &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;String; 15: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 18: invokevirtual #14 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String; 21: astore_0 22: new #11 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 25: dup 26: invokespecial #12 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 29: aload_0 30: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 33: ldc #10 &#x2F;&#x2F; String 123 35: invokevirtual #13 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 38: invokevirtual #14 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String; 41: astore_0 42: return static &#123;&#125;; Code: 0: ldc #15 &#x2F;&#x2F; String - 2: putstatic #9 &#x2F;&#x2F; Field t:Ljava&#x2F;lang&#x2F;String; 5: return&#125; &emsp;&emsp;通过以上的字节码指令可知： string1()方法中，在编译器编译的时候，由于是3个常量，所以编译器将代码优化成了一个拼接之后完整的字符串直接进行赋值； string2()方法中，和先前了解到的情况一样，调用了3次append()方法进行拼接； string3()方法中，编译器会创建一个StringBuffer对象然后再进行字符串拼接； string4()方法中，因为是进行了分段拼接，编译器这时就会创建多个StringBuffer和调用多次toString()将StringBuffer转换成String。 &emsp;&emsp;因此可知，正常情况下如果是在一行代码内进行字符串的拼接，可以不使用StringBuffer，因为编译器会在字符串拼接的时候自动创建StringBuffer来进行拼接。而如果是多段拼接，这个时候使用StringBuffer则会比String更节省内存和更加高效（因为String在多段拼接的时候会产生多个StringBuffer和String对象）。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.klavor.com/tags/Java/"},{"name":"探索发现","slug":"探索发现","permalink":"https://www.klavor.com/tags/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0/"},{"name":"反汇编","slug":"反汇编","permalink":"https://www.klavor.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"name":"字节码指令","slug":"字节码指令","permalink":"https://www.klavor.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"},{"name":"String","slug":"String","permalink":"https://www.klavor.com/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.klavor.com/tags/StringBuffer/"},{"name":"字符串拼接","slug":"字符串拼接","permalink":"https://www.klavor.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"}]},{"title":"「WP教程」WordPress文章页面首尾添加自定义内容","slug":"dev/2019/02/20190221-331","date":"2019-02-20T16:00:00.000Z","updated":"2021-01-28T17:52:36.504Z","comments":true,"path":"dev/2019/02/20190221-331.html","link":"","permalink":"https://www.klavor.com/dev/2019/02/20190221-331.html","excerpt":"","text":"&emsp;&emsp;在使用wordpress建站的过程中，总会遇到一些需要定制的功能，如回复邮件提醒，指定位置插入内容，添加验证码，赞赏功能等等。今天添加赞赏功能的时候需要将赞赏的代码插入到文章的结尾处，于是Get了这么一个wordpress知识点，在此分享出来供大家参考以及自己备忘。而后又随便添加了版权声明的内容，不亦说乎。 实现代码 添加内容到文章顶部 12345678910function add_article_copyright($content) &#123; if(!is_feed() &amp;&amp; !is_home() &amp;&amp; is_singular() &amp;&amp; is_main_query()) &#123; $title = get_the_title(); $permalink = get_permalink(); $custom_header_content = &#x27;&lt;p class=&quot;article-copyright&quot;&gt;原创文章如转载，请注明本文链接: &lt;a href=”&#x27;.$permalink.&#x27;” title=”&#x27;.$title.&#x27;”&gt;&#x27;.$permalink.&#x27;&lt;/a&gt;&lt;/p&gt;&#x27;; $content = $custom_header_content.$content; &#125; return $content;&#125;add_filter(&#x27;the_content&#x27;, &#x27;add_article_copyright&#x27;); 添加内容到文章底部 12345678910function add_article_copyright($content) &#123; if(!is_feed() &amp;&amp; !is_home() &amp;&amp; is_singular() &amp;&amp; is_main_query()) &#123; $title = get_the_title(); $permalink = get_permalink(); $custom_header_content = &#x27;&lt;p class=&quot;article-copyright&quot;&gt;原创文章如转载，请注明本文链接: &lt;a href=”&#x27;.$permalink.&#x27;” title=”&#x27;.$title.&#x27;”&gt;&#x27;.$permalink.&#x27;&lt;/a&gt;&lt;/p&gt;&#x27;; $content .= $custom_header_content; &#125; return $content;&#125;add_filter(&#x27;the_content&#x27;, &#x27;add_article_copyright&#x27;); 代码解析&emsp;&emsp;从上面的代码可以看出大致上是一样的，只是在拼接$content内容的时候先后顺序不一样。一个是将指定内容置于文章头部，另一个是将指定内容置于文章尾部。 1234//将内容拼接到文章头部$content = $custom_header_content.$content;//将内容拼接到文章尾部$content .= $custom_header_content; 注意事项&emsp;&emsp;在上述代码中用到了get_permalink()和get_the_title()两个函数，这两个函数是分别将文章链接和文章标题返回。还有与之很形似的两个函数the_permalink()和the_title()，这两个函数是分别打印文章链接和文章标题，而不是返回其内容。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.klavor.com/tags/Wordpress/"},{"name":"自定义","slug":"自定义","permalink":"https://www.klavor.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"WP教程","slug":"WP教程","permalink":"https://www.klavor.com/tags/WP%E6%95%99%E7%A8%8B/"}]},{"title":"「WP教程」WordPress通过自定义字段控制指定页面功能的开关","slug":"dev/2019/02/20190221-332","date":"2019-02-20T16:00:00.000Z","updated":"2021-01-28T17:52:36.487Z","comments":true,"path":"dev/2019/02/20190221-332.html","link":"","permalink":"https://www.klavor.com/dev/2019/02/20190221-332.html","excerpt":"","text":"&emsp;&emsp;在使用wordpress的过程中，我遇到了这样一个问题：自定义一个插件，这个插件里做的事情是在文章尾部添加一个赞赏的功能，然而我希望能够控制在指定页面显示与隐藏这个赞赏功能。而这个时候，自定义字段就起到了很大的作用，可以通过每一篇文章中自定义字段的值来决定赞赏是开启还是关闭。 &emsp;&emsp;首先，当然是为文章或者页面新增一个自定义的字段。 图1 开启自定义字段 图2 新增自定义字段 &emsp;&emsp;随后，将可以在代码中获取到该字段的值。实现代码如下： 123456789101112//在所有文章底部添加赞赏二维码function add_donate_qrcode($content) &#123; $donate_qrcode = get_post_meta(get_the_ID(), &#x27;donate_qrcode&#x27;, true); //如果donate_qrcode为off则关闭赞赏功能 //如果donate_qrcode没有定义则默认其为开启状态 if($donate_qrcode != &#x27;off&#x27; &amp;&amp; !is_feed() &amp;&amp; !is_home() &amp;&amp; is_singular() &amp;&amp; is_main_query()) &#123; $content .= &#x27;&lt;iframe style=&quot;overflow-x: hidden; overflow-y: hidden; border: 0xp none #fff; min-height: 240px;&quot; src=&quot;https://www.klavor.com/donate/index.html&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;&#x27;; &#125; return $content;&#125;add_filter(&#x27;the_content&#x27;, &#x27;add_donate_qrcode&#x27;); &emsp;&emsp;其中，get_post_meta()函数是这里的重点，通过这个函数可以获取到指定字段的值。这里通过donate_qrcode获取到文章或者页面中自定义字段的值，然后对这个值做判断来决定是开启还是关闭赞赏功能。 &emsp;&emsp;至此，一个根据自定义字段开关赞赏的功能就完成了，就这样又实现了一个功能。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.klavor.com/tags/Wordpress/"},{"name":"自定义","slug":"自定义","permalink":"https://www.klavor.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"WP教程","slug":"WP教程","permalink":"https://www.klavor.com/tags/WP%E6%95%99%E7%A8%8B/"}]},{"title":"「探索发现」通过反汇编Java字节码文件输出字节码指令探索有关i++的问题","slug":"dev/2019/02/20190220-310","date":"2019-02-19T16:00:00.000Z","updated":"2021-01-28T17:49:32.495Z","comments":true,"path":"dev/2019/02/20190220-310.html","link":"","permalink":"https://www.klavor.com/dev/2019/02/20190220-310.html","excerpt":"","text":"问题引出&emsp;&emsp;昨天下午，和一个朋友聊找工作需要复习的知识点的时候，他突然问了我这么一道程序题。 123int i = 0;i = i++;最后i是多少？ &emsp;&emsp;于是想了想便回答i = 1，但是没想到朋友说答案是i = 0。似乎有些出乎意料，印象里，i++是先将i的值赋值于指定变量后再做自增的。这里的代码不是应该是类似于 12i=i;i=i+1; &emsp;&emsp;如果是这样的话那i的值应该为1才是呀！疑惑不解！！！随后朋友便发来了几张程序运行图为他的答案做出了有力的支撑。 当i = i++时 当i = i++ + i++时 当i = i++ + i++ + i++时 &emsp;&emsp;看到了这些运行结果的截图，也不得不相信，但是心里还是充满了疑惑。 寻根问底&emsp;&emsp;对于这种现象，首先想到是不是i++与赋值操作是同时执行的？又或者，虚拟机在实现这类计算的时候是不是做了什么神奇的操作？怀抱着疑惑与求之的心态，开始了探索之旅。 i++与赋值操作是同时执行？ &emsp;&emsp;通过多次的运算后排除了这种可能性。 虚拟机是怎么实现这类运算的？ &emsp;&emsp;首先想到了Android上常见到的smali语言的虚拟机指令，所以百度了一下java相关的虚拟机指令的文章，看到了通过javap命令可以反汇编输出java虚拟机的字节码指令，于是考虑用这种方法进一步尝试。 着手实验 测试代码 &emsp;&emsp;首先写了一个简单的java测试代码，代码里面的main()方法就只有两行简单的语句。 123456public class Test &#123; public static void main(String[] args) &#123; int i = 0; i = i++; &#125;&#125; 反汇编java字节码文件 &emsp;&emsp;写好了demo之后，通过命令行窗口进行下一步操作。如图所示，通过javap命令输出反汇编后的文件内容，得到了java虚拟机的字节码指令。 理解指令处理流程 &emsp;&emsp;虽然以前有看过smali语法和一些简单的汇编语法，但是看到这个java的字节码指令后完全懵逼了。这些指令是什么意思都不知道，更别提阅读了。通过一番的搜索，查找到相关资料后，得到了一篇还比较全面的指令解释的文章。&emsp;&emsp;https://www.cnblogs.com/tenghoo/p/jvm_opcodejvm.html。&emsp;&emsp;根据文章里的内容整理出了反汇编后出现的几个指令的意思。 1234iconst_n 将int型(n)推送至栈顶istore_n 将栈顶int型数值存入第n+1个本地变量iload_n 将第n+1个int型本地变量推送至栈顶iinc n, m 局部变量自增指令,将第n+1个本地变量自增m &emsp;&emsp;顺着上面的这几条指令看，慢慢的揭开i=i++，最后i=0的神秘面纱了。 第一步指令：iconst_0 &emsp;&emsp;推送int型的数值0到栈顶中。 第二步指令：istore_1 &emsp;&emsp;将栈顶int型数值存入到第2个本地变量 第三步指令：iload_1 &emsp;&emsp;将第2个int型的本地变量推送至栈顶 第四步指令：iinc 1, 1 &emsp;&emsp;将第2个本地变量自增1 第五步指令：istore_1 &emsp;&emsp;将栈顶int型数值存入到第2个本地变量 &emsp;&emsp;根据以上的步骤可知此时的第2个本地变量的值应该是0，而i就是这第二个本地变量，因此i = 0。 后话&emsp;&emsp;很多事情都没有想象中那么简单，有时候觉得理所当然的事情，可能因为存在本质上的差别和个体上的差异而导致了不相同的结果，而此时，应该怀揣着求之与探索的精神，去追寻其根源，从而才能够从根本上去解决问题。 补充说明&emsp;&emsp;当执行了istore_n指令之后其实栈中的值应该是要弹出的，但是画图的时候没画对，现在也不想重新再画了，所以这一点需要注意一下，在这里做补充说明。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.klavor.com/tags/Java/"},{"name":"字节码","slug":"字节码","permalink":"https://www.klavor.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"},{"name":"探索发现","slug":"探索发现","permalink":"https://www.klavor.com/tags/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0/"},{"name":"反汇编","slug":"反汇编","permalink":"https://www.klavor.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"}]},{"title":"「吉他谱」天使的项链_野人看夕阳","slug":"guitar/2019/02/20190220-320","date":"2019-02-19T16:00:00.000Z","updated":"2021-01-28T17:52:36.512Z","comments":true,"path":"guitar/2019/02/20190220-320.html","link":"","permalink":"https://www.klavor.com/guitar/2019/02/20190220-320.html","excerpt":"","text":"去年还是前年的什么时候来着，请同事帮我扒了一首野人看夕阳唱的天使的项链的谱子，歌曲很好听，另外一首汽配厂我也非常推荐。经过了很长的时间之后我差一点忘记了这首歌曲怎么弹了，还好慢慢琢磨和回想了一下终于又将曲谱补齐了。为了给热爱音乐的广大网友们做出一些贡献，所以花了整整一晚上的时间把这首天使的项链制作成谱共享出来供热爱音乐的小伙伴们下载。因为是第一次制作吉他谱，会有很多不足之处，还望指教。也希望能与志同道合的小伙伴们多多交流。感谢！！ 如果需要GTP格式吉他谱的朋友欢迎留言，后期也会在本文里附上下载链接，再次谢谢大家的支持！！！","categories":[{"name":"音乐空间","slug":"音乐空间","permalink":"https://www.klavor.com/categories/%E9%9F%B3%E4%B9%90%E7%A9%BA%E9%97%B4/"}],"tags":[{"name":"吉他谱","slug":"吉他谱","permalink":"https://www.klavor.com/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"},{"name":"天使的项链","slug":"天使的项链","permalink":"https://www.klavor.com/tags/%E5%A4%A9%E4%BD%BF%E7%9A%84%E9%A1%B9%E9%93%BE/"},{"name":"野人看夕阳","slug":"野人看夕阳","permalink":"https://www.klavor.com/tags/%E9%87%8E%E4%BA%BA%E7%9C%8B%E5%A4%95%E9%98%B3/"}]},{"title":"「开源文档」Android JsBridge使用教程","slug":"dev/2019/02/20190219-307","date":"2019-02-18T16:00:00.000Z","updated":"2021-01-28T17:49:32.513Z","comments":true,"path":"dev/2019/02/20190219-307.html","link":"","permalink":"https://www.klavor.com/dev/2019/02/20190219-307.html","excerpt":"","text":"如何使用JsBridge?Js调用Android原生 对于Android开发者 创建Api功能类 如需新增一个新的功能类提供给Js调用，则自定义一个类并实现JsApi接口，然后在此类中定义具有一个JsContext形参的方法，并通过@JsAnnotation注解此方法，以表明此方法是提供给Js调用。 123456789101112public class LogJsApi implements JsApi &#123; @JsAnnotation public void d(JsContext jsContext) &#123; Log.d(jsContext.get(&quot;tag&quot;, &quot;undefine&quot;), jsContext.get(&quot;msg&quot;, &quot;undefine&quot;)); &#125; @JsAnnotation public void i(JsContext jsContext) &#123; Log.i(jsContext.get(&quot;tag&quot;, &quot;undefine&quot;), jsContext.get(&quot;msg&quot;, &quot;undefine&quot;)); &#125;&#125; 在JsApiMapping中声明 在JsApiMapping类中的buildMapping()方法里通过mApiMapping.put(功能名称, 功能类)新增一个功能类。 12345678910111213141516171819202122232425public class JsApiMapping &#123; private static HashMap&lt;String, Class&lt;? extends JsApi&gt;&gt; mApiMapping; private JsApiMapping() &#123; &#125; public static HashMap&lt;String, Class&lt;? extends JsApi&gt;&gt; getApiMapping() &#123; if (mApiMapping == null) &#123; synchronized (JsApiMapping.class) &#123; if (mApiMapping == null) &#123; mApiMapping = new HashMap&lt;&gt;(); buildMapping(); &#125; &#125; &#125; return mApiMapping; &#125; private static void buildMapping() &#123; mApiMapping.put(&quot;log&quot;, LogJsApi.class); mApiMapping.put(&quot;dialog&quot;, DialogJsApi.class); mApiMapping.put(&quot;nativeJs&quot;, NativeJsApi.class); &#125;&#125; 完成以上步骤之后，在程序运行时会根据 功能名称 和其中的方法名来生成一个可供js调用的函数，如： 1jsApi.log.d(arg) 而调用函数需要传递的参数应根据功能类提供者所定义的参数格式为主。 方法回调 当提供给Js的方法被调用时，会传入一个JsContext对象的实参，此实参可以通过get()和put()方法进行数据的读取和写入，也可通过调用这个对象的success(),cancel(),error()方法来回调Js。 对于Web开发者 调用Android原生代码 Web开发人员可以通过如下方式调用原生代码： 1234jsApi.log.d(&#123; tag : &#x27;wsy&#x27;, msg : arg&#125;) 同时也可以通过另外一种形式调用： 12345678910111213function log(level, arg) &#123; if (level == 0) &#123; jsApi.log.d(&#123; tag : &#x27;wsy&#x27;, msg : arg &#125;) &#125; else if (level == 1) &#123; jsApi.log.i(&#123; tag : &#x27;cmf&#x27;, msg : arg &#125;) &#125;&#125; Web开发者可以根据需求自行灵活运用。 方法回调实现 当需要和Android原生代码之间进行交互的时候，就需要通过回调实现，但回调是否生效还需要看功能类提供者是否实现了回调功能。 Js中方法回调的书写形式如下： 1234567891011121314151617function show() &#123; jsApi.dialog.show(&#123; title : &quot;警告&quot;, message : &quot;请不要点击取消!&quot;, positive : &quot;知道了&quot;, negative : &quot;我就要&quot;, success : function(arg) &#123; alert(arg.msg); &#125;, cancel : function(arg) &#123; alert(arg.msg); &#125;, error : function(arg, err) &#123; alert(err); &#125; &#125;)&#125; 参数中具体返回的数据主要由功能类提供者所决定。 Android原生调用Js 对于Android开发者 通过KWebView的nativeJs方法进行调用Js函数 nativeJs方法有三个形参。第一个形参是指Js的函数名；第二个形参是指传递给Js的数据；第三个形参是指回调的处理。 12345678910111213141516171819202122findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; JsContext jsContext = new JsContext(kwv.getWebViewProxy()); kwv.nativeJs(&quot;test&quot;, jsContext, new NativeCallback() &#123; @Override public void success(JsContext jsContext) &#123; Log.d(&quot;cmf&quot;, &quot;success...&quot;); &#125; @Override public void cancel(JsContext jsContext) &#123; Log.d(&quot;cmf&quot;, &quot;cancel...&quot;); &#125; @Override public void error(JsContext jsContext) &#123; Log.d(&quot;cmf&quot;, &quot;error...&quot;); &#125; &#125;); &#125;&#125;); 方法回调 如步骤1中调用nativeJs()方法时的第三个形参，只需要在其中处理回调即可。最终是否能被成功回调，需由Web开发者实现。 对于Web开发者 定义一个函数 如果需要添加一个给Android原生代码调用的函数，则需要在代码中进行定义。如下： 123function test(arg, rtn) &#123; rtn.success(arg);&#125; 函数体内可根据具体需求来实现。其中，第一个形参是指Android原生代码传过来的数据；第二个形参是指回调函数的对象，里面包含了success()，cancel()和error()三个回调方法。 不足之处JsBridge库中，暂未实现监听的功能，目前仅限于一次回调，如Js调用Android原生代码后回调了一次之后，第二次再调用回调方法将不会再生效，因为此时回调的对象已经移除出回调的集合了。 关于我邮箱: &#x6c;&#x65;&#x65;&#64;&#x6b;&#108;&#x61;&#118;&#111;&#x72;&#x2e;&#x63;&#x6f;&#x6d;扣扣: 2262693733微博: http://weibo.com/lihuan1991主页: https://www.klavor.com","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.klavor.com/tags/Android/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.klavor.com/tags/Javascript/"},{"name":"开源文档","slug":"开源文档","permalink":"https://www.klavor.com/tags/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"},{"name":"JsBridge","slug":"JsBridge","permalink":"https://www.klavor.com/tags/JsBridge/"}]},{"title":"「解决方案」命令行执行flutter doctor无响应原因追踪及解决","slug":"dev/2019/01/20190117-163","date":"2019-01-16T16:00:00.000Z","updated":"2021-01-28T17:48:10.346Z","comments":true,"path":"dev/2019/01/20190117-163.html","link":"","permalink":"https://www.klavor.com/dev/2019/01/20190117-163.html","excerpt":"","text":"问题再现&emsp;&emsp;最近在学习Flutter开发，在一次配置环境的过程中遇到了一个比较尴尬的坑，不过最终还是把这个坑给填掉了，再此进行一些分享，希望后来者遇到同样的问题时可以轻松的解决。&emsp;&emsp;从下图中可以看出，前面几条flutter doctor命令执行的时候总是未响应，通过各种方式执行都是一样的结果，但是dart命令是能够正常执行。起初还以为是环境变量配置的有问题，但是后来把环境变量改了又改，并且把flutter包换了又换，但是现象一直未得到解决。 解决问题寻求网络帮助&emsp;&emsp;遇到这种难题第一时间想到的便是百度，但是各种关键词搜索了一番之后，竟然没有找到一篇关于这种现象的解决方案，大部分都是flutter命令使用教程，如用flutter doctor去查看环境是否配置完成，或者通过flutter doctor --android-licenses命令去接受Android SDK的一些协议许可。&emsp;&emsp;后来，又尝试了必应和Google搜索，也无果之后，放弃了通过网络寻求帮助解决的方法。 大胆试错&emsp;&emsp;由于只有flutter的命令执行的时候无响应，所以起初认为是程序包有问题。于是通过再次解压程序压缩包和配置环境变量之后，问题仍然存在。&emsp;&emsp;随后，判断了不是程序包的问题之后开始去监控应用进程的变化。 任务管理器&emsp;&emsp;从图中可以发现在任务管理器的详细信息栏里看到了很多个git正在执行，并且很卡。 性能&emsp;&emsp;从性能栏页面底部的打开资源监视器进入到资源监控页面 资源监视器&emsp;&emsp;然后在网络一栏看到了多个git和一个git-remote-http在运行，并且git-remote-http的地址指向了**https://ec2-37-112--117-223.ap-southeast-01.compute.amazonaws.com**。这里的图片是后来截的，所以看不到那个程序和地址了。 根源&emsp;&emsp;到这里，可以猜到很可能是由于git导致的问题，但是先前安装过flutter都没有问题，这一次重装系统之后就突然有问题了。所以就尝试着把git软件给删除并重新安装，然后奇迹的发现了flutter doctor命令可以正常执行了。&emsp;&emsp;于是又倒退回去复现了一下问题，发现是安装git的时候选项选的有问题导致了和flutter冲突。&emsp;&emsp;如下图，选择了Use Window’s default console window的选项来安装git软件之后，git bash是直接用的window的命令窗口来执行命令。正是因为选中了这个选项所以导致flutter命令无响应的问题。&emsp;&emsp;所以如果你出现了和我一样的问题可以尝试重新安装git软件，并在这一步选择Use MinTTY的选项来安装。 完美填坑&emsp;&emsp;经过不断的试错，终于将这个问题解决了，flutter命令也可以正常执行了。如图，通过VSCode开发工具可以正常的执行flutter create hello_flutter创建新的flutter项目。 写在最后&emsp;&emsp;遇到问题要大胆试错，只要不断的尝试就会离问题的起因更近，最后找到解决问题的办法。如果你的flutter遇到了相同的问题而又不是由于git导致的话，也可以通过类似的方式不断试错并找到最终的解决方案。也欢迎各位同行可以在评论里分享自己解决问题的方法。&emsp;&emsp;乐于分享，共同进步。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://www.klavor.com/tags/flutter/"},{"name":"git","slug":"git","permalink":"https://www.klavor.com/tags/git/"},{"name":"解决方案","slug":"解决方案","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"命令行无响应","slug":"命令行无响应","permalink":"https://www.klavor.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%97%A0%E5%93%8D%E5%BA%94/"}]},{"title":"「教程」自定义编辑字体及输出TTF/OTF字体文件","slug":"dev/2018/12/20181226-126","date":"2018-12-25T16:00:00.000Z","updated":"2021-01-28T18:16:49.374Z","comments":true,"path":"dev/2018/12/20181226-126.html","link":"","permalink":"https://www.klavor.com/dev/2018/12/20181226-126.html","excerpt":"","text":"前期准备&emsp;&emsp;首先在开始编辑字体之前需要做一些准备工作，包括素材、编辑工具等。需要的准备工作：&emsp;&emsp;1. 自定义字体的svg文件（因为svg是矢量图所以效果好些），必要的时候可以下载自己准备修改的字体文件用来作为基板进行编辑。&emsp;&emsp;2. 字体编辑器，如 百度字体平台 或者 FontCreator 等字体编辑器。 编辑步骤百度字体平台&emsp;&emsp;因为FontCreator软件是收费的，所以这里选择使用百度字体平台，效果差不多。有需要可以自行搜索网上破解版软件，如果是土豪建议买正版。 FontEditor&emsp;&emsp;点击导航栏中的FontEditor进入到字体编辑器页面。 创建字体&emsp;&emsp;点击页面左上角中的新建按钮创建一个新的项目。 &emsp;&emsp;然后点击菜单栏中的导入将对应的素材导入到编辑器中。 编辑字体&emsp;&emsp;导入字体成功后如下图所示。如果是导入svg增加的只是一个字形，这时候可以对字体进行增删改操作。 设置代码点&emsp;&emsp;完成了编辑工作之后还有一步比较重要的工作，就是给每一个字形设置代码点。如果是导入的字体默认已经有代码点了。但如果是svg或者图片等形式导入的字形则需要自己进行设置。具体的代码点的值可以参考其他字体文件中的设置参数。例如$31代表的是数字1，$32代表的是数字2等等。 导出字体文件&emsp;&emsp;设置代码点完成之后就大功告成了。根据需要点击页面顶部的TTF、WOFF或ZIP导出对应的文件。 结尾&emsp;&emsp;导出的字体文件可以应用到电脑系统、H5页面或者手机应用等地方。自己定制和打造一款属于自己的字体还是很有意思的。","categories":[{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"自定义字体","slug":"自定义字体","permalink":"https://www.klavor.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/"},{"name":"FontEditor","slug":"FontEditor","permalink":"https://www.klavor.com/tags/FontEditor/"},{"name":"TTF","slug":"TTF","permalink":"https://www.klavor.com/tags/TTF/"},{"name":"OTF","slug":"OTF","permalink":"https://www.klavor.com/tags/OTF/"},{"name":"WOFF","slug":"WOFF","permalink":"https://www.klavor.com/tags/WOFF/"},{"name":"百度字体平台","slug":"百度字体平台","permalink":"https://www.klavor.com/tags/%E7%99%BE%E5%BA%A6%E5%AD%97%E4%BD%93%E5%B9%B3%E5%8F%B0/"}]}],"categories":[{"name":"心情随笔","slug":"心情随笔","permalink":"https://www.klavor.com/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"},{"name":"开发之路","slug":"开发之路","permalink":"https://www.klavor.com/categories/%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%AF/"},{"name":"音乐空间","slug":"音乐空间","permalink":"https://www.klavor.com/categories/%E9%9F%B3%E4%B9%90%E7%A9%BA%E9%97%B4/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.klavor.com/tags/Hexo/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.klavor.com/tags/Wordpress/"},{"name":"科学上网","slug":"科学上网","permalink":"https://www.klavor.com/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://www.klavor.com/tags/Shadowsocks/"},{"name":"一键安装","slug":"一键安装","permalink":"https://www.klavor.com/tags/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"},{"name":"油管","slug":"油管","permalink":"https://www.klavor.com/tags/%E6%B2%B9%E7%AE%A1/"},{"name":"Github","slug":"Github","permalink":"https://www.klavor.com/tags/Github/"},{"name":"teddysun","slug":"teddysun","permalink":"https://www.klavor.com/tags/teddysun/"},{"name":"代码评审","slug":"代码评审","permalink":"https://www.klavor.com/tags/%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1/"},{"name":"Gerrit","slug":"Gerrit","permalink":"https://www.klavor.com/tags/Gerrit/"},{"name":"解决办法","slug":"解决办法","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"name":"Code Review","slug":"Code-Review","permalink":"https://www.klavor.com/tags/Code-Review/"},{"name":"Android","slug":"Android","permalink":"https://www.klavor.com/tags/Android/"},{"name":"防暴力点击","slug":"防暴力点击","permalink":"https://www.klavor.com/tags/%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%82%B9%E5%87%BB/"},{"name":"安卓开发","slug":"安卓开发","permalink":"https://www.klavor.com/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.klavor.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://www.klavor.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.klavor.com/tags/CentOS/"},{"name":"文件配置","slug":"文件配置","permalink":"https://www.klavor.com/tags/%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/"},{"name":"源码安装","slug":"源码安装","permalink":"https://www.klavor.com/tags/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"},{"name":"问题汇总","slug":"问题汇总","permalink":"https://www.klavor.com/tags/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"},{"name":"阿里云","slug":"阿里云","permalink":"https://www.klavor.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Java","slug":"Java","permalink":"https://www.klavor.com/tags/Java/"},{"name":"CRC","slug":"CRC","permalink":"https://www.klavor.com/tags/CRC/"},{"name":"算法原理","slug":"算法原理","permalink":"https://www.klavor.com/tags/%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"},{"name":"多项式","slug":"多项式","permalink":"https://www.klavor.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"理幻","slug":"理幻","permalink":"https://www.klavor.com/tags/%E7%90%86%E5%B9%BB/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.klavor.com/tags/Javascript/"},{"name":"JS教程","slug":"JS教程","permalink":"https://www.klavor.com/tags/JS%E6%95%99%E7%A8%8B/"},{"name":"CSDN，copyright","slug":"CSDN，copyright","permalink":"https://www.klavor.com/tags/CSDN%EF%BC%8Ccopyright/"},{"name":"版权声明","slug":"版权声明","permalink":"https://www.klavor.com/tags/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/"},{"name":"解决方案","slug":"解决方案","permalink":"https://www.klavor.com/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"name":"Gradle","slug":"Gradle","permalink":"https://www.klavor.com/tags/Gradle/"},{"name":"dependency","slug":"dependency","permalink":"https://www.klavor.com/tags/dependency/"},{"name":"依赖包","slug":"依赖包","permalink":"https://www.klavor.com/tags/%E4%BE%9D%E8%B5%96%E5%8C%85/"},{"name":"探索发现","slug":"探索发现","permalink":"https://www.klavor.com/tags/%E6%8E%A2%E7%B4%A2%E5%8F%91%E7%8E%B0/"},{"name":"反汇编","slug":"反汇编","permalink":"https://www.klavor.com/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"},{"name":"字节码指令","slug":"字节码指令","permalink":"https://www.klavor.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"},{"name":"String","slug":"String","permalink":"https://www.klavor.com/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://www.klavor.com/tags/StringBuffer/"},{"name":"字符串拼接","slug":"字符串拼接","permalink":"https://www.klavor.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"},{"name":"自定义","slug":"自定义","permalink":"https://www.klavor.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"WP教程","slug":"WP教程","permalink":"https://www.klavor.com/tags/WP%E6%95%99%E7%A8%8B/"},{"name":"字节码","slug":"字节码","permalink":"https://www.klavor.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81/"},{"name":"吉他谱","slug":"吉他谱","permalink":"https://www.klavor.com/tags/%E5%90%89%E4%BB%96%E8%B0%B1/"},{"name":"天使的项链","slug":"天使的项链","permalink":"https://www.klavor.com/tags/%E5%A4%A9%E4%BD%BF%E7%9A%84%E9%A1%B9%E9%93%BE/"},{"name":"野人看夕阳","slug":"野人看夕阳","permalink":"https://www.klavor.com/tags/%E9%87%8E%E4%BA%BA%E7%9C%8B%E5%A4%95%E9%98%B3/"},{"name":"开源文档","slug":"开源文档","permalink":"https://www.klavor.com/tags/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"},{"name":"JsBridge","slug":"JsBridge","permalink":"https://www.klavor.com/tags/JsBridge/"},{"name":"flutter","slug":"flutter","permalink":"https://www.klavor.com/tags/flutter/"},{"name":"git","slug":"git","permalink":"https://www.klavor.com/tags/git/"},{"name":"命令行无响应","slug":"命令行无响应","permalink":"https://www.klavor.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%97%A0%E5%93%8D%E5%BA%94/"},{"name":"自定义字体","slug":"自定义字体","permalink":"https://www.klavor.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/"},{"name":"FontEditor","slug":"FontEditor","permalink":"https://www.klavor.com/tags/FontEditor/"},{"name":"TTF","slug":"TTF","permalink":"https://www.klavor.com/tags/TTF/"},{"name":"OTF","slug":"OTF","permalink":"https://www.klavor.com/tags/OTF/"},{"name":"WOFF","slug":"WOFF","permalink":"https://www.klavor.com/tags/WOFF/"},{"name":"百度字体平台","slug":"百度字体平台","permalink":"https://www.klavor.com/tags/%E7%99%BE%E5%BA%A6%E5%AD%97%E4%BD%93%E5%B9%B3%E5%8F%B0/"}]}